{
  "hash": "206367e54f9b7c5adc79420439cf1bae",
  "result": {
    "markdown": "---\ntitle: \"Day 3 - Advent of Code 2023\"\ndescription: \"Commitment to a data structure\"\nauthor:\n  - name: Jim Gardner\n    url: https://jimgar.github.io/jimgar/\ndate: 2023-12-15\ncategories: [R, base R, Advent of Code, Advent of Code 2023]\nexecute:\n  echo: true\ndraft: false\n---\n\n\nAoC day 3 using base R. I got caught in the matrix ðŸ¥²\n\n![](matrix.jpeg){fig-align=\"center\" fig-alt=\"Green text streaming vertically down a black background. It looks like the code seen in The Matrix movies.\" width=\"60%\"}\n\nSpoilers ahead.\n\n# Solution without commentary\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ninput <- readLines(\"input.txt\")\n\nschematic <- matrix(\n  unlist(strsplit(input, \"\")),\n  ncol = 140,\n  nrow = 140,\n  byrow = TRUE\n)\n\ninput_as_string <- paste(input, collapse = \"\")\n\nnumber_locations <- gregexpr(\"\\\\d+\", input_as_string)\nnumbers <- as.integer(regmatches(input_as_string, number_locations)[[1]])\n\nsymbols <- regmatches(\n  input_as_string, gregexpr(\"[^0-9.]\", input_as_string)\n)[[1]] |>\n  unlist() |>\n  unique()\n\nparts_and_stars <- Map(\n  \\(number_location, number) {\n    # Convert the first digit's index from the stringified input to its\n    # equivalent position in the schematic/matrix\n    row <- ceiling(number_location / 140)\n    column <- number_location - ((row - 1) * 140)\n\n    # Bounding box. Account for boxes falling outside matrix edges\n    left <- if ((column - 1) == 0) 1 else column - 1\n    right <- if ((column + nchar(number)) == 141) 140 else column + nchar(number)\n    top <- if ((row - 1) == 0) NULL else row - 1\n    bottom <- if ((row + 1) == 141) NULL else row + 1\n\n    # Collect up characters in the box\n    above <- if (is.null(top)) NULL else schematic[top, left:right]\n    middle <- schematic[row, left:right]\n    below <- if (is.null(bottom)) NULL else schematic[bottom, left:right]\n\n    chars <- c(above, middle, below)\n\n    part <- if (any(symbols %in% chars)) number else NA\n\n    # Find index of *, if it exists\n    star <- NA\n\n    if (\"*\" %in% above) {\n      star <- paste(top, left + (which(\"*\" == above) - 1))\n    }\n    if (\"*\" %in% middle) {\n      star <- paste(row, left + (which(\"*\" == middle) - 1))\n    }\n    if (\"*\" %in% below) {\n      star <- paste(bottom, left + (which(\"*\" == below) - 1))\n    }\n\n    data.frame(parts = part, stars = star)\n  },\n  number_locations[[1]],\n  numbers\n) |>\n  do.call(rbind, args = _)\n\n# Part 1\nsum(parts_and_stars$parts, na.rm = TRUE)\n\n# Part 2\ndupes <- parts_and_stars$stars[duplicated(parts_and_stars$stars, incomparables = NA)]\ngears <- parts_and_stars[parts_and_stars$stars %in% dupes, ]\n\nsum(aggregate(gears$parts, by = list(Stars = gears$stars), prod)$x)\n```\n:::\n\n\n# Part 1\n\n## The problem\n--- Day 3: Gear Ratios ---\n\nYou and the Elf eventually reach a gondola lift station; he says the gondola lift will take you up to the **water source**, but this is as far as he can bring you. You go inside.\n\nIt doesn't take long to find the gondolas, but there seems to be a problem: they're not moving.\n\n\"Aaah!\"\n\nYou turn around to see a slightly-greasy Elf with a wrench and a look of surprise. \"Sorry, I wasn't expecting anyone! The gondola lift isn't working right now; it'll still be a while before I can fix it.\" You offer to help.\n\nThe engineer explains that an engine part seems to be missing from the engine, but nobody can figure out which one. If you can **add up all the part numbers** in the engine schematic, it should be easy to work out which part is missing.\n\nThe engine schematic (your puzzle input) consists of a visual representation of the engine. There are lots of numbers and symbols you don't really understand, but apparently **any number adjacent to a symbol**, even diagonally, is a \"part number\" and should be included in your sum. (Periods (.) do not count as a symbol.)\n\nHere is an example engine schematic:\n\n```\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n```\n\nIn this schematic, two numbers are not part numbers because they are not adjacent to a symbol: 114 (top right) and 58 (middle right). Every other number is adjacent to a symbol and so is a part number; their sum is **4361**.\n\nOf course, the actual engine schematic is much larger. **What is the sum of all of the part numbers in the engine schematic?**\n\n## Solution\n\nRight, so in AoC day 1 I saw my first ever matrix. That means I now see matrices everywhere. reading the problem, I envision the schematic as a matrix, and there's a bounding box drawn around each cluster of digits. The box encompasses all of the characters surrounding the digits, too. All I have to do is get the indices of the digits and it should be pretty simple maths from there.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- readLines(\"input.txt\")\n\ninput[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"............................................411.....................363..134.........463.775..........................506...................\"\n[2] \"......429...836..$............../..960........*.............+..........*...=....381.....*........67......426.....=..../...304...............\"\n[3] \".........*...&...641..........924..*.........855....492..495.......476.927.......*.........680...../.&....*.....713......*..................\"\n```\n:::\n\n```{.r .cell-code}\nlength(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 140\n```\n:::\n\n```{.r .cell-code}\nall(nchar(input) == 140)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nYeah, so this thing is 140 x 140 characters. I'm now absolutely committed to the idea of it being a matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nschematic <- matrix(\n  unlist(strsplit(input, \"\")),\n  ncol = 140,\n  nrow = 140,\n  byrow = TRUE\n)\n\nschematic[1:6, 1:12]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\n[1,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"   \".\"   \".\"  \n[2,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \"4\"  \"2\"  \"9\"  \".\"   \".\"   \".\"  \n[3,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \"*\"   \".\"   \".\"  \n[4,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \"9\"   \"0\"   \"0\"  \n[5,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"   \".\"   \".\"  \n[6,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \"7\"  \"2\"   \"1\"   \".\"  \n```\n:::\n:::\n\n\nAnd this is where my brain ground to a halt. I completely boxed myself in - pun not intended but very much appropriate - because I became fixated on the matrix. I didn't want to do another list extravaganza. I kept printing the data and thinking, \"It's a fucking cube. A cube! MATRIX IS THE ANSWER!!!\"\n\nSo yeah after a couple of hours trying to figure out how I would capture the digits, which reached a low point when I considered lapplying through every index in the matrix ðŸ’€, I knew it was time to look for \"inspiration.\"\n\nWhich came in the form of Adam Austin [again](https://github.com/ataustin/advent-of-code/blob/main/y2023/d03/solution.R). Did he use a matrix? No. But our ideas for how to solve were actually very similar. I used his approach of turning the input into a single string to unlock everything else that would make the matrix work. \n\nThat's right. I still kept on with the matrix idea. We learn by doing hard things, right? Or by making things hard? Something like that... ðŸ˜…\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput_as_string <- paste(input, collapse = \"\")\n\n# The first position for each group of numbers\nnumber_locations <- gregexpr(\"\\\\d+\", input_as_string)\nnumber_locations[[1]][1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  45  69  74  86  90 119 147 153 176 221\n```\n:::\n\n```{.r .cell-code}\n# The actual numbers in each group\nnumbers <- as.integer(regmatches(input_as_string, number_locations)[[1]])\nnumbers[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 411 363 134 463 775 506 429 836 960 381\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsymbols <- regmatches(\n  input_as_string, gregexpr(\"[^0-9.]\", input_as_string)\n)[[1]] |>\n  unlist() |>\n  unique()\n\n  symbols\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"$\" \"/\" \"*\" \"+\" \"=\" \"&\" \"%\" \"#\" \"@\" \"-\"\n```\n:::\n:::\n\n\nOnce I've got access to all the characters in a bounding box, I'll need to check if at least one of them is in this vector of symbols. If so, the numbers are a \"part\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparts_and_stars <- Map(\n  \\(number_location, number) {\n    # Convert the first digit's index from the stringified input to its\n    # equivalent position in the schematic/matrix\n    row <- ceiling(number_location / 140)\n    column <- number_location - ((row - 1) * 140)\n\n    # Bounding box. Account for boxes falling outside matrix edges\n    left <- if ((column - 1) == 0) 1 else column - 1\n    right <- if ((column + nchar(number)) == 141) 140 else column + nchar(number)\n    top <- if ((row - 1) == 0) NULL else row - 1\n    bottom <- if ((row + 1) == 141) NULL else row + 1\n\n    # Collect up characters in the box\n    above <- if (is.null(top)) NULL else schematic[top, left:right]\n    middle <- schematic[row, left:right]\n    below <- if (is.null(bottom)) NULL else schematic[bottom, left:right]\n\n    chars <- c(above, middle, below)\n\n    part <- if (any(symbols %in% chars)) number else NA\n\n    # For part 2. Find index of *, if it exists\n    star <- NA\n\n    if (\"*\" %in% above) {\n      star <- paste(top, left + (which(\"*\" == above) - 1))\n    }\n    if (\"*\" %in% middle) {\n      star <- paste(row, left + (which(\"*\" == middle) - 1))\n    }\n    if (\"*\" %in% below) {\n      star <- paste(bottom, left + (which(\"*\" == below) - 1))\n    }\n\n    data.frame(parts = part, stars = star)\n  },\n  number_locations[[1]],\n  numbers\n) |>\n  do.call(rbind, args = _)\n\nhead(parts_and_stars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  parts stars\n1   411  2 47\n2   363  2 72\n3   134  <NA>\n4   463  2 89\n5   775  2 89\n6   506  <NA>\n```\n:::\n:::\n\n\nTo be fair, I think this code is actually fine. It works and makes logical sense. I wasn't too happy about including the star bit, which is for part 2 of the problem. Originally it wasn't a part of the `Map` and I had to go back and add it. I'll explain more in a moment.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(parts_and_stars$parts, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 536202\n```\n:::\n:::\n\n\n# Part 2\n\n## The problem\n--- Part Two ---\n\nThe engineer finds the missing part and installs it in the engine! As the engine springs to life, you jump in the closest gondola, finally ready to ascend to the water source.\n\nYou don't seem to be going very fast, though. Maybe something is still wrong? Fortunately, the gondola has a phone labeled \"help\", so you pick it up and the engineer answers.\n\nBefore you can explain the situation, she suggests that you look out the window. There stands the engineer, holding a phone in one hand and waving with the other. You're going so slowly that you haven't even left the station. You exit the gondola.\n\nThe missing part wasn't the only issue - one of the gears in the engine is wrong. A **gear** is any `*` symbol that is adjacent to **exactly two part numbers**. Its **gear ratio** is the result of multiplying those two numbers together.\n\nThis time, you need to find the gear ratio of every gear and add them all up so that the engineer can figure out which gear needs to be replaced.\n\nConsider the same engine schematic again:\n\n```\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n```\n\nIn this schematic, there are **two** gears. The first is in the top left; it has part numbers `467` and `35`, so its gear ratio is `16345`. The second gear is in the lower right; its gear ratio is `451490`. (The `*` adjacent to `617` is not a gear because it is only adjacent to one part number.) Adding up all of the gear ratios produces **`467835`**.\n\n**What is the sum of all of the gear ratios in your engine schematic?**\n\n## Solution\n\nA gear is a star that's in the bounding box of two parts. I was already tracking the potential parts in the `Map`, so I also grabbed the indices of any star that appeared. As a reminder, here's the dataframe I'm working with\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(parts_and_stars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  parts stars\n1   411  2 47\n2   363  2 72\n3   134  <NA>\n4   463  2 89\n5   775  2 89\n6   506  <NA>\n```\n:::\n:::\n\n\nThe index of a star is unique. It's basically an ID. So if a star's ID appears more than once next to a part, it is a gear.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndupes <- parts_and_stars$stars[duplicated(parts_and_stars$stars, incomparables = NA)]\ndupes[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"2 89\"  \"2 47\"  \"2 72\"  \"3 10\"  \"3 36\"  \"3 82\"  \"3 107\" \"3 122\" \"4 56\" \n[10] \"4 70\" \n```\n:::\n\n```{.r .cell-code}\ngears <- parts_and_stars[parts_and_stars$stars %in% dupes, ]\ngears[1:10, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   parts stars\n1    411  2 47\n2    363  2 72\n4    463  2 89\n5    775  2 89\n7    429  3 10\n9    960  3 36\n10   381  3 82\n12   426 3 107\n13   304 3 122\n16   855  2 47\n```\n:::\n\n```{.r .cell-code}\nsum(aggregate(gears$parts, by = list(Stars = gears$stars), prod)$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 78272573\n```\n:::\n:::\n\n\nEnding on an Adam Austin double-whammy: `aggregate` with `prod` inside.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}