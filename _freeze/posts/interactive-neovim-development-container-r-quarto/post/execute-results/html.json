{
  "hash": "0b2d1fa2956079043e28ca11269e3869",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"A containerised Neovim dev environment for R and Quarto\"\ndescription: \"I got nerd-sniped.\"\nauthor:\n  - name: Jim Gardner\n    url: https://jimgar.github.io/jimgar/\ndate: 2025-05-01\ncategories: [R, Quarto, Python, Neovim, Container, Docker, Podman]\nengine: knitr\ndraft: true\n---\n\n::: {.cell}\n<style type=\"text/css\">\n.figure-caption {\n    text-align: center;\n}\n\n.center {\n    text-align: center;\n}\n</style>\n:::\n\n\n\n\n![R script in Neovim running in Wezterm](nvim.png){fig-align=\"center\"}\n\n## The question\n\nOver on Mastodon [Pete Jones](https://hcommons.social/@petejones) asked the following:\n\n> [...] I'll jump straight to my noob questions which I'm hoping the #Rstats community can help me answer:\n>\n> - Does anyone have any good recommendations for primers/video tutorials etc that are particularly geared towards (social science) research uses of containers?\n> - I can see how containers make sense for sharing your research environment at the end of a project for reproducibility, but how sensible is it to be doing all your iterating and exploratory stuff inside a container during the research? Do folks just do all that on their host system and then containerise it when they're done?\n> - What's the advantage of using, say, Apptainer versus podman versus something like rix? There seems to be a lot of overlap so it's hard to know which one to dive into.\n> For context, my coding work is almost entirely in the form of interactive sessions throwing stuff at the REPL and making data visualisations etc, and rarely a scripts-as-jobs type of workflow. In other words, I want to be sat inside a command line environment writing and evaluating code on the fly.\n\nMy response was basically that it's straightforward-ish to use an image with RStudio Server, or VS Code. That's how I work these days, barely touching the system installation of R.\n\nIt turns out that Pete uses Neovim as his IDE, so those images aren't that useful. Thankfully, he recently wrote [a nice blog post](https://petejon.es/posts/2025-01-29-using-neovim-for-r/) specifically about using Neovim for interactive R and Quarto work. Reading over that post again, and looking at his nvim config files, the desire to prove it was possible took me over.\n\nA couple of days later I'm happy to say it is possible. The rest of this post is dedicated to explaining how.\n\n## Terminology\n\nContainers aren't tied to Docker, like most people think. There's an open source alternative called [Podman](https://podman.io/), and that's what I used to build and run the container in question. Podman is essentially a drop-in replacement for Docker.\n\nI also refer to the recipe for the container image not as a Dockerfile, but a [Containerfile](https://github.com/containers/buildah/discussions/3170).\n\n## The Containerfile explanation\n\nHere it is in full.\n\nOne note to mention is that I haven't consistently pinned versions throughout. That would definitely be worthwhile, but it takes a bit of time and I don't have it right now.\n\nFrom Pete's config, I knew he would need Python (because the radian R REPL is written in it), R, Quarto, and of course, Neovim. You can see that installing and configuring these different tools happen in short blocks, most of which are heredocs. It's fine to have small scripts that get copied in and run instead, but I used heredocs so that everything is together in the same file.\n\n```Dockerfile\nFROM docker.io/library/python:3.13-bookworm\n\n# Python setup. Makes a venv and sets it as the default Python interpreter\nENV VIRTUAL_ENV=/root/.venv\nRUN python -m venv $VIRTUAL_ENV\nENV PATH=\"$VIRTUAL_ENV/bin:$PATH\"\n\n# Install radian, a Julia-inspired R REPL written in Python\nRUN pip install -U radian\n\nENV R_VERSION=\"4.5.0\"\nENV QUARTO_VERSION=\"1.7.29\"\n\nRUN <<EOF\n# Install R\n# Taken from https://github.com/r-lib/rig?tab=readme-ov-file#installing-rig-on-linux-\n\n# Get their certificate\ncurl -L https://rig.r-pkg.org/deb/rig.gpg -o /etc/apt/trusted.gpg.d/rig.gpg\nsh -c 'echo \"deb http://rig.r-pkg.org/deb rig main\" > /etc/apt/sources.list.d/rig.list'\napt-get update\n\n# Now rig is available to install\napt-get install r-rig\n\n# Install this version of R\nrig add ${R_VERSION}\n\necho \"options(repos = c(CRAN = 'https://packagemanager.posit.co/cran/__linux__/bookworm/latest'))\\n\\n\" >> ~/.Rprofile\nRscript -e \"options(warn = 2); pak::pak(c('knitr', 'rmarkdown', 'languageserver', 'nx10/httpgd'))\"\nEOF\n\nRUN <<EOF\n# Set up the R graphics driver\necho \"if (interactive()) {\\n\n  if ('httpgd' %in% .packages(all.available = TRUE)) {\\n\n    options(device = function(...) {\\n\n      httpgd::hgd(host = '0.0.0.0', port = 9001, token = FALSE)\\n\n    })\\n\n  }\\n\n}\\n\\n\" >> ~/.Rprofile\nEOF\n\nRUN <<EOF\n# Install Quarto.\n# Slightly modified from \n# https://docs.posit.co/resources/install-quarto.html\n\nmkdir -p /opt/quarto/${QUARTO_VERSION}\n\ncurl -o quarto.tar.gz -L \\\n    \"https://github.com/quarto-dev/quarto-cli/releases/download/v${QUARTO_VERSION}/quarto-${QUARTO_VERSION}-linux-amd64.tar.gz\"\n\ntar -zxvf quarto.tar.gz \\\n    -C \"/opt/quarto/${QUARTO_VERSION}\" \\\n    --strip-components=1\n\nrm quarto.tar.gz\n\n# Symlink so that `quarto` can be used as a command\nln -s /opt/quarto/${QUARTO_VERSION}/bin/quarto /usr/local/bin/quarto\n\n# Verify successful installation\nquarto check\nEOF\n\n# deno is required for one of the plugins\nCOPY --from=denoland/deno:bin /deno /usr/local/bin/deno\n\nRUN <<EOF\n# Neovim plugin system deps\n\napt-get update\napt-get install -y --no-install-recommends ripgrep fd-find\n\n# Instructions for fd from: https://github.com/sharkdp/fd?tab=readme-ov-file#on-debian\nmkdir -p ~/.local/bin/fd\nln -s $(which fdfind) ~/.local/bin/fd\necho 'export PATH=\"$PATH:/$HOME/.local/bin\"' >> ~/.bashrc\nEOF\n\nRUN <<EOF\n# Get Neovim config\n\nmkdir -p ~/.config/nvim\ncurl -o config.tar.gz -L \"https://codeberg.org/pjphd/neovim_config/archive/main.tar.gz\"\ntar -zxvf config.tar.gz -C ~/.config/nvim --strip-components=1\n\nrm config.tar.gz\nEOF\n\nRUN <<EOF\n# Install Neovim\n# Taken from https://github.com/neovim/neovim/blob/master/INSTALL.md#pre-built-archives-2\n\ncurl -LO https://github.com/neovim/neovim/releases/latest/download/nvim-linux-x86_64.tar.gz\nrm -rf /opt/nvim\ntar -C /opt -xzf nvim-linux-x86_64.tar.gz\necho 'export PATH=\"$PATH:/opt/nvim-linux-x86_64/bin\"' >> ~/.bashrc\n\nrm nvim-linux-x86_64.tar.gz\nEOF\n\n# Tidy up apt\nRUN apt clean && rm -rf /var/lib/apt/lists/*\n\nCMD /bin/bash\n```\n\n### Python\n\n```Dockerfile\nFROM docker.io/library/python:3.13-bookworm\n\n# Python setup. Makes a venv and sets it as the default Python interpreter\nENV VIRTUAL_ENV=/root/.venv\nRUN python -m venv $VIRTUAL_ENV\nENV PATH=\"$VIRTUAL_ENV/bin:$PATH\"\n\n# Install radian, a Julia-inspired R REPL written in Python\nRUN pip install -U radian\n```\n\nI used an \"official\" Python base image with version 3.13, and Debian Bookworm as the Linux distro. At time of writing bookworm is the latest release of Debian.\n\nPython no longer allows you to install packages into the system version of Python. I think that's fine - virtual environments are great (I wish R's ecosystem was better in this regard). So here, I make a venv and add that version of Python to the container's PATH. This means when you invoke `python` or `pip` it uses the venv. If you don't take the step of adding it to the PATH your subsequent `RUN` commands, e.g. `pip install`ing requirements, will use the system Python installation. Not a lot of people know this so I thought it was worth pointing out. Handily, this also means you never need to `source /venv/bin/activate`.\n\n### R\n\n```Dockerfile\nRUN <<EOF\n# Install R\n# Taken from https://github.com/r-lib/rig?tab=readme-ov-file#installing-rig-on-linux-\n\n# Get their certificate\ncurl -L https://rig.r-pkg.org/deb/rig.gpg -o /etc/apt/trusted.gpg.d/rig.gpg\nsh -c 'echo \"deb http://rig.r-pkg.org/deb rig main\" > /etc/apt/sources.list.d/rig.list'\napt-get update\n\n# Now rig is available to install\napt-get install r-rig\n\n# Install this version of R\nrig add ${R_VERSION}\n\necho \"options(repos = c(CRAN = 'https://packagemanager.posit.co/cran/__linux__/bookworm/latest'))\\n\\n\" >> ~/.Rprofile\nRscript -e \"options(warn = 2); pak::pak(c('knitr', 'rmarkdown', 'languageserver', 'nx10/httpgd'))\"\nEOF\n\nRUN <<EOF\n# Set up the R graphics driver\necho \"if (interactive()) {\\n\n  if ('httpgd' %in% .packages(all.available = TRUE)) {\\n\n    options(device = function(...) {\\n\n      httpgd::hgd(host = '0.0.0.0', port = 9001, token = FALSE)\\n\n    })\\n\n  }\\n\n}\\n\\n\" >> ~/.Rprofile\nEOF\n```\n\nI use [rig](https://github.com/r-lib/rig) to install R. Then, I set the CRAN repo to the Posit Public Package Manager, specifically the version with binaries for Bookworm. This means the packages don't need to build from source so the installation process is nice and fast.\n\nRig comes with [pak](https://github.com/r-lib/pak), a package installation manager for R. This fantastic package can find and install Linux system dependencies for R packages, which is a real blessing when making your own container. Here I just install the packages I know are required for Quarto (knitr, rmarkdown) and Neovim (languageserver, httpgd).\n\nSpeaking of httpgd, I add some configuration to the Rprofile for this. The purpose of this package is to offer a graphics device, for viewing plots and HTML. Basically, the browser on your computer can be used to view images provided by httpgd while it runs inside the container.\n\n### Quarto\n\n```Dockerfile\nRUN <<EOF\n# Install Quarto.\n# Slightly modified from \n# https://docs.posit.co/resources/install-quarto.html\n\nmkdir -p /opt/quarto/${QUARTO_VERSION}\n\ncurl -o quarto.tar.gz -L \\\n    \"https://github.com/quarto-dev/quarto-cli/releases/download/v${QUARTO_VERSION}/quarto-${QUARTO_VERSION}-linux-amd64.tar.gz\"\n\ntar -zxvf quarto.tar.gz \\\n    -C \"/opt/quarto/${QUARTO_VERSION}\" \\\n    --strip-components=1\n\nrm quarto.tar.gz\n\n# Symlink so that `quarto` can be used as a command\nln -s /opt/quarto/${QUARTO_VERSION}/bin/quarto /usr/local/bin/quarto\n\n# Verify successful installation\nquarto check\nEOF\n```\n\nThere's nothing particularly special going on here. I basically just followed Posit's instructions.\n\n### Neovim dependencies\n\n```Dockerfile\n# deno is required for one of the plugins\nCOPY --from=denoland/deno:bin /deno /usr/local/bin/deno\n\nRUN <<EOF\n# Neovim plugin system deps\n\napt-get update\napt-get install -y --no-install-recommends ripgrep fd-find\n\n# Instructions for fd from: https://github.com/sharkdp/fd?tab=readme-ov-file#on-debian\nmkdir -p ~/.local/bin/fd\nln -s $(which fdfind) ~/.local/bin/fd\necho 'export PATH=\"$PATH:/$HOME/.local/bin\"' >> ~/.bashrc\nEOF\n```\n\n`deno` is a system dep of `peek.nvim`, and thankfully they had straightforward instructions that allowed me to copy the binary from one of their own container images.\n\nPretty much everyone using Neovim will use a plugin called `Telescope`, which requires `fd`, and I think `ripgrep` too.\n\n### Neovim config\n\n```Dockerfile\nRUN <<EOF\n# Get Neovim config\n\nmkdir -p ~/.config/nvim\ncurl -o config.tar.gz -L \"https://codeberg.org/pjphd/neovim_config/archive/main.tar.gz\"\ntar -zxvf config.tar.gz -C ~/.config/nvim --strip-components=1\n\nrm config.tar.gz\nEOF\n```\n\nThis grabs Pete's config files from Codeberg and puts them into the expected place in the file system.\n\n### Neovim\n\n```Dockerfile\nRUN <<EOF\n# Install Neovim\n# Taken from https://github.com/neovim/neovim/blob/master/INSTALL.md#pre-built-archives-2\n\ncurl -LO https://github.com/neovim/neovim/releases/latest/download/nvim-linux-x86_64.tar.gz\nrm -rf /opt/nvim\ntar -C /opt -xzf nvim-linux-x86_64.tar.gz\necho 'export PATH=\"$PATH:/opt/nvim-linux-x86_64/bin\"' >> ~/.bashrc\n\nrm nvim-linux-x86_64.tar.gz\nEOF\n```\n\nAgain, pretty straightforward - followed instructions provided by the Neovim maintainers.\n\n### Tidy and cmd\n\n```Dockerfile\n# Tidy up apt\nRUN apt clean && rm -rf /var/lib/apt/lists/*\n\nCMD /bin/bash\n```\n\nThe lists of available packages are just bloat at this point, so I get rid of them. And I add a new cmd, which is what gets run when the container is booted up. In this case it's just bash, so that the user gets a flexible launch/base point to work from.\n\n## Build the container\n\nThis bit is really simple. In a terminal `cd` to the directory where the Containerfile lives. Then run:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\npodman build -t pete . --arch=linux/amd64\n```\n:::\n\n\n\n\nIt will take a minute or two depending on your internet and processing power.\n\n`pete` is the name I've given the image. The `.` just means 'look in the current directory for the Containerfile'. The `--arch=linux/amd64` is to \"set the architecture of the image to be built, and that of the base image to be pulled, if the build uses one, to the provided value instead of using the architecture of the build host\". I'm on an arm64 Macbook, which is the build host, but most of the things we're installing into the image are explicitly the amd64 versions.\n\nOne thing to bear in mind is the \"build context\" when you build the image. **All** the files in the directory containing the Containerfile will get copied into the build context, so that they've available for the build. Podman will look like it's frozen if you have large files in the build context. In reality, it's copying them. You can either add them to a `.Containerignore` (aka `.Dockerignore`) or do the build in a different directory.\n\n## Run the container\n\nBefore running, I made a tiny Quarto file in the same directory as the Containerfile, called `index.qmd`:\n\n\n\n\n::: {.cell}\n\n````{.markdown .cell-code}\n---\ntitle: \"test\"\n---\n\n## Quarto\n\nQuarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.\n\n```{r}\nmtcars\n```\n\n```{r}\nplot(mtcars)\n```\n````\n:::\n\n\n\n\nThis is when the magic happens.\n\nIn the terminal (from the directory with `index.qmd`) run:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\npodman run --rm -it -p 9000:9000 -p 9001:9001 -v ./:/test_project pete\n```\n:::\n\n\n\n\nThe container will start. We've set it up to run with an interactive terminal, forwarding ports 9000 and 9001 from within the container to the same ports on the host machine, and also mounted the current directory to `/test_project` inside the container.\n\nThe ports will be used to preview the qmd file and for showing plots made during an interactive R session. The volume mounting means that we can edit the qmd file inside the container and the changes will persist on the host machine - in fact we can also make entirely new files in `/test_project` and they will appear on the host file system!\n\nWith the container running, start neovim:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nnvim\n```\n:::\n\n\n\n\nIt will take a moment to install all of the plugins and LSPs. When it's done follow any prompts that come up.\n\nOnce finished, do `:tabnew`, then `:terminal`. Go into Insert mode and run:\n\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nquarto preview test_project/index.qmd --host 0.0.0.0 --port 9000\n```\n:::\n\n\n\n\nIn your web browser, go to `localhost:9000`. You should see a live preview of the Quarto document.\n\nNow, in the other nvim tab, let's `:e test_project/index.qmd`. Go ahead and change something in the file, and `:w`. Look at the browser and the doc should update right in front of you.\n\nFor the cherry on top, let's start a REPL at the same time and view a plot. With the config at current time of writing `localleader` is set to `Space`. Do `<localleader>rS`, this should open a radian terminal. Now highlight the line of R code `plot(mtcars)` with `Shift + V`, then do `<localleader>r` followed by `Return`. Radian should say that it's running a httpgd server. Go to your browser and in a new tab/window go to `localhost:9001/live`. There's your plot!\n\nThis shows how Neovim with a plot viewer and Quarto live preview, plus a 'live link' between the container and host file systems is possible.\n\n## Is it worth it?\n\nThe short answer is, I'm not sure.\n\nR itself is quite mature and so are many of its most well-used packages, so developing on your system and then putting the finished project into a container is fine. Creating a dev environment with a lot of dependencies, like in this case, is fairly involved. It's also annoying that the Neovim packages have to install every time you start the container, though there may be a solution to that I've yet to find.\n\nAt the same time, once you have a couple of Containerfiles, like this dev one, and another that encapsulates the final project, you've got most of what you need for future projects. It's also amazing how quickly we can adapt to slightly different workflows like this. I think it's really cool that Neovim can offer the REPL and native terminal. I'm also a believer that the ephemeral nature of containers forces us to be a lot better about capturing code, and making sure it runs from start to end. Too often people rely heavily on the REPL and are scared to restart their IDE in case their analysis no longer works, for some reason.\n\n## Two extra learnings\n\nTwo extras things I learned during this process:\n\n1) Ever wondered about what has gone into a base image that you are using? As in, what did the Containerfile / Dockerfile have in it? That's possible to get. First run `podman image ls` and note down the image id of the image you're interested in. Then use `podman history --no-trunc image_id`, where `image_id` is (you guessed it) the image id. The output isn't clean like a Containerfile - it contains timestamps and suchlike - and it is in reverse order. But it's still a good one to know, particularly if you find yourself in a situation like I did while making this post: The Containerfile disappeared after a forced laptop restart. Ten minutes of tedious reformatting later, all was repaired.\n\n2) How to close buffers. I used to open files in Neovim sometimes using the `:e` (alias of `:edit`) command. I knew that these buffers had to be closed somehow but never figured it out. It's actually very simple. You can list all buffers with `:buffers`. Then you can do `db #`, where `#` is the number of the buffer to be closed. ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}