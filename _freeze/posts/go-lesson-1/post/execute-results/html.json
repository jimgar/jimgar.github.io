{
  "hash": "3d38548a4dd5d2038ee3f1a0a48004d2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Touring Go: Lesson 1\"\ndescription: \"Blah\"\nauthor:\n  - name: Jim Gardner\n    url: https://jimgar.github.io/jimgar/\ndate: 2024-05-17\ncategories: []\nexecute:\n  eval: true\nengine: knitr\ndraft: true\n---\n\n::: {.cell}\n<style type=\"text/css\">\n.figure-caption {\n    text-align: center;\n}\n\n.center {\n    text-align: center;\n}\n</style>\n:::\n\n\n# Overview\n\nSome small intro crap goes here.\n\n# Examples\n\n## Packages, Imports, Exported names\n\n\n::: {.cell}\n\n```{.go .cell-code}\npackage main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n)\n\nfunc main() {\n    fmt.Println(\"My favourite number is\", rand.Intn(123))\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMy favourite number is 57\n```\n\n\n:::\n:::\n\n\n- The file starting with package `main` is going to be the entrypoint for your program\n- To use a function from an imported package you do `package.Function()`\n- Exported functions start with a capital letter, e.g. `Intn()`\n- The style of enclosing multiple package imports in a single parens is called a \"factored import\" statement\n\n## Functions\n\n\n::: {.cell}\n\n```{.go .cell-code}\npackage main\n\nimport \"fmt\"\n\nfunc add(x int, y int) int {\n    return x + y\n}\n\nfunc main() {\n    fmt.Println(add(42, 13))\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n55\n```\n\n\n:::\n:::\n\n\n- Types come **after** variable names\n- If the args for a function have the same type you can specify it once, for both\n \n\n::: {.cell}\n\n```{.go .cell-code}\nfunc add(x, y int) int {\n\treturn x + y\n}\n```\n:::\n\n\n## Multiple results\n\n\n::: {.cell}\n\n```{.go .cell-code}\npackage main\n\nimport \"fmt\"\n\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap(\"hello\", \"world\")\n\tfmt.Println(a, b)\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nworld hello\n```\n\n\n:::\n:::\n\n\n- Functions can return multiple values, like `return y, x` in `swap()`\n\n## Named results\n\n\n::: {.cell}\n\n```{.go .cell-code}\npackage main\n\nimport \"fmt\"\n\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\n}\n\nfunc main() {\n\tfmt.Println(split(17))\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n7 10\n```\n\n\n:::\n:::\n\n\n- This is a horrific practice known as a \"naked return\"\n- I expect this is controversial. Only ever recommended in *A Tour of Go* for short functions\n- The plain `return` will return the formals/args provided where the function is created. It's supposed to be a form of self-documentation\n\n## Variables\n\n\n::: {.cell}\n\n```{.go .cell-code}\npackage main\n\nimport \"fmt\"\n\nvar c, python, java bool\n\nfunc main() {\n\tvar i int\n\tfmt.Println(i, c, python, java)\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0 false false false\n```\n\n\n:::\n:::\n\n\n- You can declare lists of variables both at the package and function level\n- Variables declared without initial values are given the \"zero value\"\n- Zero values are\n  - `0` for numerics\n  - `false` for boolean\n  - `\"\"` (empty string) for strings\n\n\n::: {.cell}\n\n```{.go .cell-code}\nvar (\n    ABoolean bool   = true\n    AString  string = \"a string\"\n)\n```\n:::\n\n\n- Variables can be \"factored\", just like imports\n\n\n\n::: {.cell}\n\n```{.go .cell-code}\npackage main\n\nimport \"fmt\"\n\nvar i, j int = 1, 2\n\nfunc main() {\n\tvar c, python, java = true, false, \"no!\"\n\tfmt.Println(i, j, c, python, java)\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 2 true false no!\n```\n\n\n:::\n:::\n\n\n- If you declare with initialiser values (one per variable), then the type is passed from the initialiser to the variable\n\n## Short assignment :=\n\n\n::: {.cell}\n\n```{.go .cell-code}\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i, j int = 1, 2\n\tk := 3\n\tc, python, java := true, false, \"no!\"\n\n\tfmt.Println(i, j, k, c, python, java)\n}\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 2 3 true false no!\n```\n\n\n:::\n:::\n\n\n- Inside functions the short assignment statement `:=` can be used for assigning implicitly typed variables. Either do `var hi = 11` or `hi := 11` \n\n## Constants\n\n- Declared just like variables, but using `const`\n- Can be char, string, bool, or numeric\n- Can't use := to assign\n\n\n## Sub-title\n\n\n::: {.cell}\n\n```{.go .cell-code}\n-- Some go code\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}